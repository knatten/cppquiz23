For `const int *`, according to §[basic.type.qualifier]¶2, 'Except for array types, a compound type ([basic.compound]) is not cv-qualified by the cv-qualifiers (if any) of the types from which it is compounded.' Since a pointer type is considered to be a compound type (as defined in §[basic.compound]¶1.3) and is not itself `const`, the type `const int *` is not considered to be const, therefore `0` is outputted. An alternative explanation to this is that, while we're not allowed to change the value of the value pointed to the pointer, we can change what variable the pointer points to.

For `const int [1]`, as defined by §[basic.type.qualifier]¶6, 'An array type whose elements are cv-qualified is also considered to have the same cv-qualifications as its elements.' Since the array's element type is const, the array type itself is also const, therefore `1` is outputted.

`const int **` and `const int (*)[1]` define pointer types that are not themselves const, so `0` is outputted for both. `const int *[1]` is an array of a pointer type that is not const, so neither is it considered const. Finally, for `const int [1][1]`, since the member type of the array is `const int [1]`, which is const, the entire array type itself is const.